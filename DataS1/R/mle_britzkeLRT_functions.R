####################################################
### 2-species Britzke et al. (2002) MLE functions ##
####################################################

# log lhood fun
lhood_twospp <- function(theta, phi_mat, n_vec, spp_idx = 1){
  n <- n_vec[spp_idx]
  N <- sum(n_vec)
  if(spp_idx == 1){
    p <- theta*phi_mat[1,1] + (1-theta)*phi_mat[1,2]    
  } else {
    p <- theta*phi_mat[2,2] + (1-theta)*phi_mat[2,1]
  }
  # phi_mat%*%theta_vec could be simpler, then row = spp_idx
  # currently theta is the point est for just one spp
  lhood <- dbinom(n, size = N, prob = p, log = T)
  out <- lhood
  return(out)
}


# -log lhood fun
lhood_twospp_min <- function(theta, phi_mat, n_vec){
  n1 <- n_vec[1]
  N <- sum(n_vec)
  p <- theta*phi_mat[1,1] + (1-theta)*phi_mat[1,2]
  lhood <- dbinom(n1, size = N, prob = p, log = T)
  out <- lhood
  return(-out)
}


# Britzke MLE LRT function for one visit, calls lhood
lrt_fun <- function(theta_hat, phi_mat, n_vec, spp_idx){
  l_num <- lhood_twospp(0, phi_mat = phi_mat,
                        n_vec = n_vec, spp_idx = spp_idx)
  l_den <- lhood_twospp(theta_hat, phi_mat = phi_mat,
                        n_vec = n_vec, spp_idx = spp_idx)
  ln_lambda <- l_num - l_den
  ts <- -2*ln_lambda
  pvalue <- 1 - pchisq(ts, df = 1)
  decision <- ifelse(pvalue < 0.05, 1, 0)
  out <- list("LRT_TS" = ts, "pvalue" = pvalue,
              "y_noFP" = decision)
  return(out)
}

# Britzke MLE LRT function for data generated by
# Wright et al. 2002 MEE fake data simulation function -- 
# uses numerical optimization
britzke_mle2spp <- function(ambig_det, phi_mat,
                            z_vec, n_visit = 3,
                            length_seq = 1000, spp_idx = 1){
  unconf_n <- apply(ambig_det, 1, as.vector)
  K <- nrow(phi_mat)
  z_spp <- rep(z_vec, each = n_visit)
  tot_visit <- ncol(unconf_n)
  mle <- matrix(rep(NA), nrow = tot_visit,
                ncol = K)
  pvalue <- rep(NA, tot_visit)
  LRT_y <- rep(NA, tot_visit)
  mle_length <- rep(NA, tot_visit)
  theta <- seq(0.01, 0.99, length = length_seq)
  for(i in 1:tot_visit){
    lhood <- apply(cbind(theta), 1, lhood_twospp,
                   phi_mat = phi_mat, n_vec = unconf_n[,i], spp_idx = spp_idx)
    test <- sum(lhood) == 0
    if(test == 1){
      mle[i, ] <- rep(NA, K)
      pvalue[i] <- NA
      LRT_y[i] <- NA
      mle_length[i] <- NA
    } else {
      approx_mle <- theta[which(lhood == max(lhood))]
      if(length(approx_mle) > 1){
        mle_length[i] <- length(approx_mle)
        approx_mle <- mean(approx_mle)
      }
      mle_length[i] <- 1
      mle[i, ] <- c(approx_mle, 1-approx_mle)
      lrt <- lrt_fun(theta_hat = mle[i,spp_idx], phi_mat = phi_mat,
                     n_vec = unconf_n[,i], spp_idx = spp_idx)
      pvalue[i] <- lrt$pvalue
      LRT_y[i] <- lrt$y_noFP
    }
  }
  y_naive <- ifelse(unconf_n[spp_idx,] > 1, 1, 0)
  df_out <- cbind(ambig_det, "mle" = mle,
                  "mle_length" = mle_length,
                  "lrt_pvalue" = pvalue,
                  "Y_noFP" = LRT_y, "Z_true" = z_spp,
                  "Y_naive" = y_naive)
  num_lrt <- sum(!is.na(LRT_y))
  prop_agree <- sum(LRT_y == z_spp, na.rm = TRUE)/num_lrt
  out <- list("summ_df" = df_out, "num_lrt" = num_lrt,
              "prop_agree" = prop_agree)
  return(out)
}

# a function for a vector of counts where the first
# element is the total number of calls assigned to
# spp1, and the second is the total number of
# bat calls assigned to spp2. Returns the point est from
# the ML-estimator not the "Britzke-mle"
mle_2spp <- function(n_vec, phi_mat, adjusted = TRUE){
  # binomial lhood
  mle_p <- n_vec/sum(n_vec)
  # invariance prop of mle
  mle_theta1 <- (n_vec[1] - sum(n_vec)*phi_mat[1,2])/
    (sum(n_vec)*(phi_mat[1,1]-phi_mat[1,2]))
  # if mle_theta1 < 0 or >1 adjust to 0 or 1, respectively
  if(adjusted == TRUE){
    mle_theta1 <- ifelse(mle_theta1 > 1, 1,
                         ifelse(mle_theta1 < 0, 0, mle_theta1))
  }
  # see highlight in  britzke-mle-functions.pdf to verify
  mle <- c(as.vector(mle_theta1), as.vector(1-mle_theta1))
  return(mle)
}

# closed-form LRT function
mle_closedform_2spp <- function(ambig_det, phi_mat,
                                z_vec, n_visit = 3, spp_idx = 1,
                                adjusted = TRUE){
  unconf_n <- apply(ambig_det, 1, as.vector)
  K <- nrow(phi_mat)
  z_spp <- rep(z_vec, each = n_visit)
  tot_visit <- ncol(unconf_n)
  n_site <- tot_visit/n_visit 
  pvalue <- rep(NA, tot_visit)
  LRT_y <- rep(NA, tot_visit)
  mle <- data.frame(t(apply(unconf_n, 2, mle_2spp,
                            adjusted = adjusted,
                            phi_mat = phi_mat)))
  names(mle) <- paste0("mle_theta", 1:2)

  for(i in 1:tot_visit){
    lrt <- lrt_fun(mle[i,spp_idx], phi_mat = phi_mat,
                   n_vec = unconf_n[,i], spp_idx = spp_idx)
    pvalue[i] <- lrt$pvalue
    LRT_y[i] <- lrt$y_noFP
  }

  y_naive <- ifelse(unconf_n[spp_idx,] > 1, 1, 0)
  df_out <- cbind(ambig_det, 
                  "mle" = mle, "lrt_pvalue" = pvalue,
                  "Y_noFP" = LRT_y, "Z_true" = z_spp,
                  "Y_naive" = y_naive, 
                  "Site_ID" = rep(1:n_site, each = n_visit), 
                  "Visit_ID" = rep(1:n_visit, n_site))
  num_lrt <- sum(!is.na(LRT_y))
  prop_Zagree <- sum(LRT_y == z_spp, na.rm = TRUE)/num_lrt
  out <- list("summ_df" = df_out, "num_lrt" = num_lrt,
              "prop_agree" = prop_Zagree)
  return(out)
}

# function to create dh matrices for use in occu from
# the results based on the MLE and the observed detection
mle_dh <- function(mle_output, n_visit = 3, spp_idx = 1){
  mle_df <- mle_output$summ_df
  y_mle <- mle_df$Y_noFP
  # first two columns are AutoIDs for SPP1 and SPP2 in
  # that order, so take the AutoIds for spp_idx
  y_obs <- mle_df[ , spp_idx]
  no_dets <- which((is.na(y_mle) & y_obs == 0) == TRUE)
  y_mle[no_dets] <- 0
  ncol <- n_visit
  nrow <- dim(mle_df)[1]/ncol
  # takes the MLE-corrected Ys and creates DH matrix
  dh_remove <- matrix(y_mle, nrow = nrow, ncol = ncol,
                      byrow = TRUE)
  # takes observed Ys and creates DH matrix
  dh_naive <- matrix(y_obs, nrow = nrow, ncol = ncol,
                     byrow = TRUE)
  dh_naive[dh_naive > 0] <- 1

  return(list("dh_remove" = dh_remove,
              "dh_naive" = dh_naive))
}

# function to obtain estimates from occu in the unmarked
# package. Compares MLE-based data (remove) to directly
# using observed det/non-det data (naive)
occu_compare_simple <- function(mle_output, n_visit = 3,
                         n_site = 10, dg_psi=dg_value, spp_idx = 1){
  # create detection history matrix with Y_noFP MLE results
  dh <- mle_dh(mle_output = mle_output,
               n_visit = n_visit, spp_idx = spp_idx)
  dh_rem <- dh$dh_remove
  dh_n <- dh$dh_naive

  #switching to just create a flag
  fail_rem<-ifelse(sum(dh_rem) == 0,1, 0)

  fail_naive<-ifelse(sum(dh_n) == 0,1, 0)
    y_rem <- unmarked::unmarkedFrameOccu(y = dh_rem)
    fit_remove <- unmarked::occu(formula = ~ 1 ~ 1, data = y_rem)
    psi_rem <- arm::invlogit(fit_remove@estimates@estimates$state@estimates)
    se_psi_rem <- arm::invlogit(sqrt(fit_remove@estimates@estimates$state@covMat))
    lb_psi_rem <- arm::invlogit((fit_remove@estimates@estimates$state@estimates)-
                                  1.96*sqrt(fit_remove@estimates@estimates$state@covMat))
    ub_psi_rem <- arm::invlogit((fit_remove@estimates@estimates$state@estimates)+
                                  1.96*sqrt(fit_remove@estimates@estimates$state@covMat))
    cov_rem <-  ifelse((lb_psi_rem <= dg_psi & dg_psi <=ub_psi_rem),1, 0)
    cri_rem <- ub_psi_rem-lb_psi_rem
    # }

  y_n <- unmarked::unmarkedFrameOccu(y = dh_n)

  fit_naive <- unmarked::occu(formula = ~ 1 ~ 1, data = y_n)
  psi_naive <- arm::invlogit(fit_naive@estimates@estimates$state@estimates)
  se_psi_naive <- arm::invlogit(sqrt(fit_naive@estimates@estimates$state@covMat))

  lb_psi_naive <- arm::invlogit((fit_naive@estimates@estimates$state@estimates)-
                            1.96*sqrt(fit_naive@estimates@estimates$state@covMat))
  ub_psi_naive <- arm::invlogit((fit_naive@estimates@estimates$state@estimates)+
                            1.96*sqrt(fit_naive@estimates@estimates$state@covMat))
  cov_naive <-  ifelse((lb_psi_naive <= dg_psi &
                          dg_psi <=ub_psi_naive),1, 0)
  cri_naive <- ub_psi_naive - lb_psi_naive

  df_out <- data.frame(model = c("Remove", "Naive"),
                       psi_hat = c(psi_rem, psi_naive),
                       se_psi_hat = c(se_psi_rem, se_psi_naive),
                       X2.5. = c( lb_psi_rem,lb_psi_naive),
                       X97.5.= c( ub_psi_rem,ub_psi_naive),
                       cov = c(cov_rem,cov_naive),
                       cri_width = c(cri_rem,cri_naive),fail_flag =c( fail_rem, fail_naive)
                       )

  return(df_out)

  z_mle <- apply(dh_rem, 1, sum)
  z_mle[z_mle > 0] <- 1
  z_true <- mle_output$summ_df$Z_true[c(1:n_site)*n_visit]
  z_compare <- data.frame("Z_remove" = z_mle, "Z_true" = z_true)
  # return(list("occu_results" = df_out,
  #             "Z_compare" = z_compare))
}

############################
## Functions for MLESite  ##
############################

# Britzke MLE LRT function for one site (aggregated over visits), 
# calls lhood
lrt_fun_site <- function(theta_hat, phi_mat, n_vec, 
                         alpha = 0.05, spp_idx){
  l_num <- lhood_twospp(0, phi_mat = phi_mat,
                        n_vec = n_vec, spp_idx)
  l_den <- lhood_twospp(theta_hat, phi_mat = phi_mat,
                        n_vec = n_vec, spp_idx)
  # ts : -2ln(lambda(n))
  ln_lambda <- l_num - l_den
  ts <- -2*ln_lambda
  # ts <- exp(-2*(l_num - l_den))
  pvalue <- 1 - pchisq(ts, df = 1)
  decision <- ifelse(pvalue < alpha, 1, 0)
  out <- list("LRT_TS" = ts, "pvalue" = pvalue,
              "y_noFP" = decision)
  return(out)
}

mle_aggregated <- function(ambig_det, phi_mat,
                           z_vec, n_visit = 3, spp_idx = 1,
                           adjusted = TRUE, alpha = 0.05){
  unconf_spp1 <- matrix(ambig_det[, 1], nrow = length(z_vec),
                        ncol = n_visit, byrow = TRUE)
  unconf1 <- apply(unconf_spp1, 1, sum)
  unconf_spp2 <- matrix(ambig_det[, 2], nrow = length(z_vec),
                        ncol = n_visit, byrow = TRUE)
  unconf2 <- apply(unconf_spp2, 1, sum)
  
  unconf_n <- rbind(unconf1, unconf2)
  K <- nrow(phi_mat)
  z_spp <- z_vec
  tot_visit <- ncol(unconf_n)
  pvalue <- rep(NA, tot_visit)
  LRT_y <- rep(NA, tot_visit)
  mle <- data.frame(t(apply(unconf_n, 2, mle_2spp,
                            adjusted = adjusted,
                            phi_mat = phi_mat)))
  names(mle) <- paste0("mle_theta", 1:2)
  
  for(i in 1:tot_visit){
    lrt <- lrt_fun_site(mle[i,spp_idx], phi_mat = phi_mat,
                        n_vec = unconf_n[,i], alpha = alpha, 
                        spp_idx = spp_idx)
    pvalue[i] <- lrt$pvalue
    LRT_y[i] <- lrt$y_noFP
  }
  
  y_naive <- ifelse(unconf_n[spp_idx,] > 1, 1, 0)
  df_out <- cbind(t(unconf_n), "mle_sl" = mle, "lrt_pvalue_sl" = pvalue,
                  "Y_noFP_sl" = LRT_y, "Z_true" = z_spp,
                  "Y_naive_sl" = y_naive)
  num_lrt <- sum(!is.na(LRT_y))
  prop_Zagree <- sum(LRT_y == z_spp, na.rm = TRUE)/num_lrt
  out <- list("summ_df" = df_out, "num_lrt" = num_lrt,
              "prop_agree" = prop_Zagree)
  return(out)
}
